
    元数据索引是为公共云对象存储服务提供键值管理的核心技术，需要提供可变长的空间管理和弹性扩展功能

1、对象存储元数据API需求
    1）服务级API请求
    2）存储空间级请求
    3）对象级请求

    对象存储的元数据管理的关键在于存储空间/对象的写/读/删除/遍历操作，查询功能并不复杂也不需要高级的sql支持，基于对象存储理论无上限的海量对象管理能力，元数据
的扩展能力是关键，目前有如下元数据支持方案：
    1）数据库分区分表
        将数据库的大表切分为子表，将不同的子表放到不同的机器上实现分表
        将数据表分段划分，并将它们存放到不同的机器上
    2）NoSQL技术
    3）NewSQL技术

    基于对象存储的需求，采用NoSQL管理元数据是合理的选择

2、业界NoSQL分析
    1）键值存储
        就是kv存储
    2）宽表
        也叫做扩展记录存储，采用表、行、列模型，当不同于关系数据库，宽表中不同行的列可以不同，无需遵守关系数据库的schema定义，因此宽表也被叫做二维键值存储
    3）文档存储

    4）图数据库

    由于对象存储的元数据管理核心是解决扩展性问题，以及海量对象场景下基于存储空间和对象数据模型支撑海量的写/读/删除/遍历并发请求操作，采用NoSQ领域的键值存储技术
通过提供分布式容错能力及树组织键的机制可以有效的满足对象存储元数据的需求
    键值存储的元数据索引通常采用B树或者LSM树

3、基于B树的键值存储
    B树是一种自平衡树，能够保持数据有序，B树可以理解为二叉树的变种，即树的非叶子节点可以拥有2个以上的子节点

3.1、B树的定义
    1）m阶的B树具有以下属性：
        1、每个节点最多有m个子节点
        2、每个非叶子节点、根节点最多有M/2个子节点
        3、如果根节点不是叶子节点，那么它至少有两个子节点
        4、有k个子节点的非叶子节点拥有k-1个键
        5、所有叶子节点都在同一层
    2）每个内部节点的键将节点的子树分开，B树包含以下类型节点：
        1、内部节点：除了根节点、叶子节点之外的节点
        2、根节点：
        3、叶子节点：

    3）B树的特点：
        1、每个节点都存储数据
        2、所有节点结构相同
        3、叶子节点之间没有指针连接

3.2、B+树
    B+树的重要价值在于面向块存储的搞笑查询能力，每个节点拥有更多的子节点，从而降低IO读/写请求次数
    B+树的键的副本可以存储在内部节点，实际的键值存储在叶子节点
    叶子节点可以包含指针，指向另外的叶子节点，从而加快顺序存取速度
    采用B+树可以降低IO读/写请求次数，并且可以通过多个叶子节点紧凑存储可以减少盘的随机访问次数

4、LSM-Tree键值存储
    基于B树可以构建盘上的元数据索引，由于B树支持修改节点的键值，因此需要盘提供在位写能力，就是在数据的原始位置进行修改，随着介质的发展，HDD采用叠瓦兹记录
提升容量降低成本但只能追加写，不支持在位写，SSD采用分区名字空间，在名字空间内只能追加写，不支持在位写，而且新的文件系统(HDFS)也采用追加写模式，因此B树不再
是用于该场景，为了解决该问题谷歌公司于2004年推出基于LSM-Tree的LevelDB技术

4.1、LSM-Tree
    非常适用于大规模的写入场景，通过维护多级存储表来实现索引的组织，其中level0存储在内存中，并采用树来组织，而level1 - levelN的表将数据排序后以追加的方式
存储在磁盘上，
    数据的新写入或着删除，需要对盘上的表进行重新拍讯和归并处理以便于清理删除数据及对数据进行重新排序，保证后续的读操作和遍历操作的性能

4.2、levelDB
    levelDB在内存中采用MemTable来保存数据，在盘上采用SSTable来保存数据，磁盘上的SSTable按照分层方式组织，基于MemTable和SSTable的分层组织格式，levelDB
的写、读、迭代遍历等请求的访问流程如下：
    1）写请求流程：写请求保存在MemTable中，并保证持久化到WA，同时在skip list记录索引，就可以返回写请求完成，由于wal因此写入数据时即使系统掉电也能保证数据不丢失
    2）写请求数据由内存转盘的持久化流程：保存在MemTable中的写数据堆积到指定阀值后，必须要持久化保存到盘上，通过将MemTable转换为immutable MemTable，进入
不可修改状态，然后写入盘中的SSTable，从而保证数据写入的一致性
    3）写请求在盘上的归并流程：由于LSM-Tree是排序树，新写入数据或者删除数据后需要在不同Level层级上进行排序，从而更好的支持遍历请求，为了快速的从盘上数据
构建索引，而不是边读边排序引入磁盘的排序索引和布隆滤波器来加速SSTable的访问
    4）读请求流程：读请求首先通过内存索引(Skip list)技术查找，如果在内存中找到，则直接通过MemTable返回，如果在内存索引中没有找到，则需要在盘上查找，查找
时，按照LSM-Tree的level从1到N逐级寻找，其中盘上构建的索引和布隆滤波器可以加速查找速度
    5）迭代遍历请求：由于LSM-Tree是排序好的树，因此遍历请求需要先找到满足条件的MemTable和SSTable，然后顺序返回数据

5、键值存储布局
    1）键值融合
        将键、值合并起来保存，可以只需一次IO请求就可以完成请求，从而优化请求的时延，但是如果需要修改键名则需要一起更改，代价较高

    2）键值分离：
        将键、值分开保存，键通过地址找到值，从而需要两次IO操作才能完成请求，会增大读写的时延，但是更改键名非常方便，只需要修改地址即可

5、分布式键值存储实现
    分布式键值存储系统主要有两种实现方式：
        1）基于单机键值存储构建分布式键值系统
        2）基于分布式文件系统构建分布式键值系统

6、对象存储元数据
    业界的对象存储实现可以基于分布式数据库构建元数据或者基于分布式键值存储构建元数据

    1）基于分布式数据库构建元数据
        可以享受数据库的关系模型以及sql能力，除了支持主键外还可以提供二级索引实现更多的查询性能
        最好采用NewSQL

    2)基于分布式键值存储构建元数据
        基于分布式键值存储构建元数据技术上可以很好的满足对象存储理论上无限制的对象数量需求
        但是分布式键值存储只能针对键构建索引，也就是说只能为对象名构建索引，无法为对象更多的元数据构建索引，因此查询功能有限






1、慢sql数量增加的问题
2、业务强读问题（为什么会出现读不到数据的问题）
3、polardb底层数据存储原理
4、计算节点转发机制
5、事务支持
6、宕机导致不可访问的问题

